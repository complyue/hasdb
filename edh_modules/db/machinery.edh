
method hasReConRepr (attrVal) {
 return type(attrVal) ?<= [
    # types reconstructable from its textual representation
    nil,  # absent attribute
    BoolType, DecimalType, StringType,  # literal values
    # TODO validate deep content in a container are reconstructable from repr
    PairType, TupleType, ListType, DictType,  # containers
    ArgsPackType,  # complexer container
  ]
}

class DataBack (persistSink) {

  _last_eid = 0  # last entity identifier
  _extent = {,}

  method restore (restoreSessions) {
    for (rsid, dataIntake, sessionDoneSig) from restoreSessions do {
      go {
        defer sessionDoneSig <- rsid  # signal session done on thread term
        for txChgs from dataIntake do {
          for txChg from txChgs do case txChg of {
            nil -> break  # end-of-session
            { (eClass, eid, attrChgs) } -> case attrChgs of {

              # delete
              nil -> this._extent[eid] = nil

              # creation
              {{ SuperBack: sb }} -> {
                sb.eid != eid -> error 'bo eid from data intake mismatch, ' ++ sb.eid
                  ++ ' vs ' ++ eid
                this._extent[eid] = attrChgs
              }

              # update
              case this._extent[eid] of -> {
                nil -> runtime.error<| 'business object lost eid=' ++ eid
                { bo } -> {
                  constructor(bo) != eClass ->  runtime.warn<| 'business object '
                    ++ eid ++ ' class mismatch ' ++ constructor(bo) ++ ' vs ' ++ eClass
                  case bo of {{ SuperBack: sb }} -> {
                    ;| bo.eid != eid -> runtime.error<| 'business object eid mismatch '
                      ++ bo.eid ++ ' vs ' ++ eid
                    for (attrName, attrVal) from attrChgs do {
                      # TODO putAttr yet to be impl.
                      sb.boScope.putAttr (attrName, attrVal)
                    }
                  }
                }

            }
          }
        }
      }
    }
  }

  method superBack () {
    SuperBack(this, this._last_eid += 1)
  }

  # put the databack instance into the lexical context of its methods as `db`
  db = this

  # to be installed to every `SuperBack` as (<-^)
  method _armSuper (boScope) {
    this?boScope &> error (
      'bug: more than 1 business objects per SuperBack instance'
    )
    this.boScope = boScope

    # TODO process relationships

    # persist new business object through `db.persistSink`
    db.persistSink <- (constructor(that), this.eid, that)

    # keep a reference to it by this.eid
    db._extent[this.eid] = that
  }

  # to be installed to every `SuperBack` as (<-@) and (*<-@)
  method _setBoAttr (attrKey, attrVal) case type(attrVal) of {

    hasReConRepr(attrVal) -> {
      hasReConRepr(that?$attrKey) -> {
        db.persistSink <- (constructor(that), this.eid, [(attrKey, attrVal)])

        # update the business object's attribute value
        that$attrKey = attrVal

        # TODO `continue` will let the other super(s) (if any present),
        # or the default behavior (if this is the bottom super) set the attr,
        # rendering the above assignment unnecessary
        continue  # pass control to other magical supers if any
      }
      error ('unexpected business object ' ++ this.eid ++ ' attr type change: '
          ++ type(that$attrKey) ++ ' to ' ++ type(attrVal))
      continue  # no magic to impose
    }

    ObjectType -> case attrVal of {
      boOldKin = that?$attrKey
      {{ SuperBack: sbNewKin }} -> {
        case boOldKin of {
          nil -> {
            # TODO adding new relationship

          }
          {{ SuperBack: sbOldKin }} -> {
            # TODO change of relationship

          }
          error ('unexpected new business object replacing old object: '
            ++ (boOldKin) ++ ' to ' ++ (attrVal))
        }
      }
      runtime.warn<| 'non-backed-object ' ++ attrVal 
        ++ ' treated as transient attribute ' ++ attrKey
    }

    # leave as normal transient attribute
    runtime.debug<| 'attribute of type ' ++ type(attrVal)
      ++ ' treated as transient attribute ' ++ attrKey 
      ++ ' for business object ' ++ this.eid
      ++ ' of class defined at ' ++ this.boScope.lexiLoc()
    continue
  }


}

class SuperBack (db, eid) {

  # relationships by class
  kins = {,}

  # handles `extends db.superBack()` from a business object's class proc
  (<-^) = db._armSuper

  # use same method impl. for (<-@) and (*<-@), treating internal/external attr
  # updates the same

  # handles `this.xxx = yyy` from a business child (referred to by `that`)
  ( <-@) = db._setBoAttr
  # handles `obj.xxx = yyy` for `obj` being a business child (referred to by `that`)
  (*<-@) = db._setBoAttr

}


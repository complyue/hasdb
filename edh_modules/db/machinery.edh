
import (

  className, newBo, 
  streamToDisk, streamFromDisk, 
  BoIndex,

  **_  # consume (drop) extra artifacts exported there, don't fail
) # 'db/ehi' is a host module installed by Haskell code,
  # relative import can only import Edh source modules
  # from local filesystem, absolute import needed here.
 'db/ehi'


# this tells persistent attributes from transient ones
method hasReConRepr( attrVal ) {
 return type( attrVal ) ?<= [
    # types reconstructable from its textual representation
    nil,  # absent attribute
    BoolType, DecimalType, StringType,  # literal values
    # TODO validate deep content in a container are reconstructable from repr
    PairType, TupleType, ListType, DictType,  # containers
    ArgsPackType,  # complexer container
  ]
}

method runDbApp(dataFileFolder, dbApp) {

  # the persister will post the fd it opened as the latest data file
  # to this sink, it'll hold this fd open until it finalized a new data
  # file at the time the db is shutdown. the fd is passed to `db.init()`
  # so business objects from that file can be restored into RAM before
  # the db app is run.
  sinkBaseDFD = sink

  # the producer procedure to be launched for db app
  producer launchApp( outlet ) {
    db = DataBack( outlet, dbApp )

    # read the most recent event from the sink, it must have been there already,
    # as `streamToDisk()` won't subscribe to the persist outlet (only after 
    # which this producer proc will run) until it resolved the latest data file.
    db.init( mre( sinkBaseDFD ) )
  }

  # serialize the stream of sunk Edh values to the specified data folder
  streamToDisk ( launchApp(), dataFileFolder, sinkBaseDFD )

}

class DataBackLifecycle {

  # this is the entry point of a db app, the concrete app can selectively
  # override some of the methods invoked here.
  method init( baseDFD ) {
    # note `that` reference won't invoke magics, just does vanilla
    # attribute resolution and do the call against the result.

    # a db app needs this chance to prepare itself for history replay
    that.bootstrap()

    producer restoreData( outlet ) {
      streamFromDisk( outlet, baseDFD )
    }
    that._replayHistory( restoreData() )

    that._dumpBaseData()

    # TODO take this chance to physically discard older files in the data 
    #      folder, as a means of automatic compacting of backing storage.

    that.run()

    that.shutdown()
  }

  # provide default impl. of the lifecycle methods so the db app does not
  # have to impl. all of them.

  method bootstrap() pass
  
  method run() pass

  method shutdown() {
    that.persistOutlet <- nil
  }

}

class DataBack {
  extends( DataBackLifecycle() )

  method __init__ (
    persistOutlet as this.persistOutlet, 
    dbApp,
  ) {
    # have the app as 1st super, so it can override DataBackLifecycle methods
    # invoked from this db instance
    extends( dbApp )
  }

  # all global indices created. a hierarchy of dicts by class then by key attr,
  # to a list of index entries for indices having the key attr involved.
  _indices = {,}

  # this method is normally called as the right-hand-expr of an assignment
  # (to an attribute of the db app), so it tends to run within a tx already,
  # we mark it with `ai` for extra certain.
  method createIndex( boClass, indexSpec, unique=false ) ai {
    idx = BoIndex( indexSpec, unique=unique, )
    bocIndices = this._indices[boClass] |>    (
                 this._indices[boClass] = {,} )
    for keyAttr from idx.keys do idx => (
      bocIndices[ keyAttr ] |>   (
      bocIndices[ keyAttr ] = [] )
    )
    return idx
  }

  # the last entity identifier allocated
  # todo change to uuid for security reasons in production, instead of the
  #      trivial natural numbers as for now
  _last_eid = 0

  # reference all live business objects by eid, with each business 
  # class having a separate dict in `_extents`
  _extents = {,}

  method superBack() {
    SuperBack( db=this, eid=this._last_eid+=1, )
  }

  # settle a new business object
  # in a tx process all attributes atm
  method _settle_obj( boEnt, sbEnt ) ai {
    persistAttrs = []
    for (attrKey, attrVal) from sbEnt._boScope.attrs() do case attrVal of {
      # referencing another business object, settle the relationship
      {{ SuperBack: sbRefEnt }} ->  {
        this._settle_rel( boEnt, sbEnt, attrKey, attrVal, sbRefEnt )

        # encounter the new relationship
        (attrKey, className(attrVal), sbRefEnt.eid) => persistAttrs
      }
      # handle trivially representable values, including `nil`
      ;| hasReConRepr(attrVal) -> {
        # encounter the new attribute value
        (attrKey, attrVal) => persistAttrs
      }
      # not to persist, treating as a transient attribute
      {#
      runtime.debug<| 'attribute of type ' ++ type(attrVal)
        ++ ' treated as transient attribute ' ++ attrKey 
        ++ ' for business object ' ++ sbEnt.eid
        ++ ' of class defined at ' ++ sbEnt._boScope.lexiLoc()
      #}
    }

    # put into global extent
    ai case this._extents[constructor(boEnt)] of {
      nil -> this._extents[constructor(boEnt)] = {
        sbEnt.eid: boEnt
      }
      { boExtent } -> {
        boExtent[sbEnt.eid] = boEnt
      }
    }

    # persist all attributes of the new business object
    this.persistOutlet <- (className(boEnt), sbEnt.eid, persistAttrs)
  }

  # settle an attribute update
  method _settle_attr( boEnt, sbEnt, attrKey, attrVal ) case attrVal of {
    # referencing another business object, settle the relationship
    {{ SuperBack: sbRefEnt }} ->  {
      this._settle_rel( boEnt, sbEnt, attrKey, attrVal, sbRefEnt )

      # persist the new relationship
      this.persistOutlet <- (className(boEnt), sbEnt.eid, [
        (attrKey, className(attrVal), sbRefEnt.eid)
      ])
    }

    # handle trivially representable values, including `nil`
    ;| hasReConRepr(attrVal) -> {
      # persist the new attribute value
      this.persistOutlet <- (className(boEnt), sbEnt.eid, [
        (attrKey, attrVal)
      ])
    }

    # not to persist, treating as a transient attribute
    {#
    runtime.debug<| 'attribute of type ' ++ type(attrVal)
      ++ ' treated as transient attribute ' ++ attrKey 
      ++ ' for business object ' ++ sbEnt.eid
      ++ ' of class defined at ' ++ sbEnt._boScope.lexiLoc()
    #}
  }

  # settle a new relationship
  method _settle_rel( boRel, sbRel, refAttr, boEnt, sbEnt ) {
    # counted reverse reference key, a pair of <rel-class>:<ref-attr>
    kinKey = constructor(boRel):refAttr

    # update the reverse reference for this very relationship
    #
    # an ai tx is used to protect against racing in adding a first `kinRCs`
    # dict for a new `kinKey` to overwrite eachother.
    ai case sbEnt._kins[kinKey] of {
      nil -> sbEnt._kins[kinKey] = {
        boRel: 1
      }
      { kinRCs } -> kinRCs[boRel] = case kinRCs[boRel] of {
        nil -> 1
        { rc } -> error('bug: dup reverse ref')
      }
    }
  }

  # cleanup an old relationship
  method _cleanup_rel( boRel, sbRel, refAttr, boEntOld, sbEntOld ) {
    # counted reverse reference key, a pair of <rel-class>:<ref-attr>
    kinKey = constructor(boRel):refAttr

    # update the reverse reference for this very relationship
    kinRCs = sbEnt._kins[kinKey]
    # the assignment has an implicit tx which is just enough
    kinRCs[boRel] = case kinRCs[boRel] of {
      1 -> nil  # assigning to nil just deletes the entry
      { nil } -> error('bug: reverse ref lost')
      { rc } -> error('bug: unexpected rc=' ++ rc)
    }
  }

  # dump all live business objects to persistent outlet, this has all live
  # objects atm to be recorded by the current backing data file, especially
  # without objects had been alive but deleted during replay of history.
  method _dumpBaseData() {
    for (boClass, boExtent) from this._extents do {
      boClassName = className(boClass)
      for (eid, boEnt) from boExtent do case boEnt of {{ SuperBack: sbEnt }} -> {
        persistAttrs = []
        for (attrKey, attrVal) from sbEnt._boScope.attrs() do case attrVal of {
          # referencing another business object
          {{ SuperBack: sbRefEnt }} ->  {
            (attrKey, className(attrVal), sbRefEnt.eid) => persistAttrs
          }
          # handle trivially representable values, including `nil`
          ;| hasReConRepr(attrVal) -> {
            # encounter the new attribute value
            (attrKey, attrVal) => persistAttrs
          }
          # not to persist, treating as a transient attribute
          {#
          runtime.debug<| 'attribute of type ' ++ type(attrVal)
            ++ ' treated as transient attribute ' ++ attrKey 
            ++ ' for business object ' ++ sbEnt.eid
            ++ ' of class defined at ' ++ sbEnt._boScope.lexiLoc()
          #}
        }
        # persist all attributes of this business object
        this.persistOutlet <- (boClassName, eid, persistAttrs)
      }
    }
  }

  # restore all business objects into RAM from the backing storage, i.e
  # lastest finalized data file. all persistent CUD operations are replayed.
  method _replayHistory( intakeSink ) {
    for persistRecord from intakeSink do case persistRecord of {
      nil -> { break }  # end of recorded history

      {( boClassName, eid, attrChgs )} -> {
        # db has the mounted DbApp as a super, resolving business classes
        # by name from there
        boClass = super?$boClassName
        if ClassType != type(boClass) then error (
          'Business class ' ++ boClassName ++ ' not available!'
        )

        # adapt to historical largest eid
        ai if eid > this._last_eid then
          this._last_eid = eid

        ai case this._extents[boClass] of {
          nil -> {
            this._extents[boClass] = (bocExtent = {,})
            boEnt = nil
          }
          { bocExtent } -> {
            boEnt = bocExtent[eid]
          }
        }

        case boEnt of {
          nil -> {
            # this bo not created yet, do non-standard construction of the
            # business object
            sbEnt = SuperBack( this, eid )
            boEnt = newBo( boClass, sbEnt )

            bocExtent[eid] = boEnt
          }
          {{ SuperBack: sbEnt }} -> {
            # already created, fallthrough to apply attr updates
            pass
          }
          error( 'bug: no SuperBack on existing bo' )
        }

        # TODO perform index update accordingly, maybe differently handled
        #      when its a new object or not; aggregate attr updates to avoid
        #      unnecessary index updates probably.

        for attrChg from attrChgs do case attrChg of {

          # delete
          nil -> {

            # disconnect all relationships
            # TODO xxx

            # unref this bo from global extent
            bocExtent[eid] = nil
          }

          # change of trivial attribute
          {( attrKey, attrVal )} -> {

            # update attr without magic
            sbEnt._boScope.put(attrKey: attrVal)

          }

          # change of relationship
          {( attrKey, refClassName, refEntIdent )} -> {

            # TODO disconnect old relationship

            # update relationship without magic
            # TODO xxx
            # sbEnt._boScope.put(attrKey: xxx)

          }

          error( 'bug: unsupported persistent attr chg pattern' )
        }
      }

      error( 'bug: unsupported persistent record pattern' )
    }
  }

}

class SuperBack {

  method __init__ (
    db as this.db, eid as this.eid,
  ) pass
  
  # informed reverse references, to referencers of `that` business object,
  # keyed by a pair of <rel-class>:<ref-attr>, then by the key attrs.
  _kins = {,}

  # create an index for sorted kins, that automatically maintained by the data
  # back.
  #
  # a kin to a business object - the referee - (being either an entity or a
  # relationship), is another relationship object - the referer - which (through
  # a specific attribute) referencing the referee.
  #
  # DataBack automatically maintains a reverse reference from the referee to
  # the referer within an BoIndex object created by `createKinIndex()` or
  # BoSet object created by `createKinSet()`, resides in the referee's SuperBack
  # super object, available as a super attribute there from the referee object.
  method createKinIndex ( kinAttr, relClass, relAttr, indexSpec, unique=false ) {
    idx = BoIndex( indexSpec, unique=unique )
    # chain the 2 assignments into single transaction
    this._kins[ relClass:relAttr ] = (
      # will be available from `that` as super attr
      this$kinAttr = idx
    )
  }

  # create a set for unordered kins, that automatically maintained by the data
  # back.
  #
  # a kin to a business object - the referee - (being either an entity or a
  # relationship), is another relationship object - the referer - which (through
  # a specific attribute) referencing the referee.
  #
  # DataBack automatically maintains a reverse reference from the referee to
  # the referer within an BoIndex object created by `createKinIndex()` or
  # BoSet object created by `createKinSet()`, resides in the referee's SuperBack
  # super object, available as a super attribute there from the referee object.
  method createKinSet ( kinAttr, relClass, relAttr ) {
    ks = BoSet()  # TODO impl. host class BoSet
    # chain the 2 assignments into single transaction
    this._kins[ relClass:relAttr ] = (
      # will be available from `that` as super attr
      this$kinAttr = ks
    )
  }

  # `extends db.superBack()` from a business object's __init__() triggers
  # this magic method, such a statement carries *persistent object creation*
  # semantic regarding the target `db` being the persistence backer.
  method (<-^) (boScope) {
    this?_boScope &> error (
      'bug: more than 1 business objects per SuperBack instance'
    )
    this._boScope = boScope

    # settle new object
    this.db._settle_obj( that, this )
  }

  # ( <-@) handles `this.xxx = yyy` from a business child (referred to by `that`)
  # (*<-@) handles `obj.xxx = yyy` for `obj` being a business child (referred to by `that`)

  method (*<-@) (attrKey, attrVal) {
    attrValOld = that?$attrKey

    # no value change, nop
    attrValOld == attrVal -> { pass }

    # apply the attribute update
    that$attrKey = attrVal

    # cleanup the old relationship
    case attrValOld of {{ SuperBack: sbRefEntOld }} ->
      this.db._cleanup_rel( that, this, attrKey, attrValOld, sbRefEntOld)

    # settle new attribute
    this.db._settle_attr( that, this, attrKey, attrVal )
  }

  # use same method impl. for (<-@) and (*<-@), treating internal/external attr
  # updates the same
  this.(<-@) = (*<-@)

  # TODO impl.
  method delete() {
    runtime.fatal<| 'deletion of backed business object not impl. yet'
  }

}


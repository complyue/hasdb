
method hasReConRepr (attrVal) {
 return type(attrVal) ?<= [
    # types reconstructable from its textual representation
    nil,  # absent attribute
    BoolType, DecimalType, StringType,  # literal values
    # TODO validate deep content in a container are reconstructable from repr
    PairType, TupleType, ListType, DictType,  # containers
    ArgsPackType,  # complexer container
  ]
}

class DataBack (persistSink) {

  _last_eid = 0  # last entity identifier
  _extent = {,}

  method restore (restoreSessions) {
    for (rsid, dataIntake, sessionDoneSig) from restoreSessions do {
      go {
        defer sessionDoneSig <- rsid  # signal session done on thread term
        for txChgs from dataIntake do {
          for txChg from txChgs do case txChg of {
            nil -> break  # end-of-session
            { (boClass, eid, attrChgs) } -> case attrChgs of {
              ai case this._extent[boClass] of {
                nil -> this._extent[boClass] = ( bocExtent = {,} )
                { bocExtent } -> { pass }
              }

              # delete
              nil -> {
                # TODO disconnect all relationships

                # unref the business object from db
                bocExtent[eid] = nil
              }

              ai if eid > this._last_eid then this._last_eid = eid

              # creation
              {{ SuperBack: sb }} -> {
                sb.eid != eid -> error 'bo eid from data intake mismatch, ' ++ sb.eid
                  ++ ' vs ' ++ eid
                # TODO connect all relationships

                # ref the business object from db
                bocExtent[eid] = attrChgs
              }

              # update
              case bocExtent[eid] of -> {
                nil -> runtime.error<| 'business object of class ' ++ boClass 
                  ++ ' lost, with eid ' ++ eid
                { bo } -> case bo of {{ SuperBack: sb }} -> {
                  for (attrKey, attrVal) from attrChgs do case attrVal of {
                    attrValOld = bo?$attrKey
                    # TODO disconnect old relationship as necessary

                    # TODO putAttr yet to be impl.
                    {( refClass: refEid )} -> {
                      # todo more friendly error msg if class/eid not found
                      boTarget = this._extent[refClass][refEid]
                      case boTarget of {{ SuperBack: sbTarget }} -> {
                        # connect the relationship
                        ai case sbTarget.kins[constructor(bo)] of {
                          nil -> {
                            sbTarget.kins[constructor(bo)] = {
                              sb.eid: (1: bo)
                            }
                          }
                          { kinCntr } -> {
                            kinCntr[sb.eid] = case kinCntr[sb.eid] of {
                              nil -> (1: bo)
                              {( rc: _bo )} -> (rc+1: bo)
                            }
                          }
                        }
                        # ref from the bo
                        sb.boScope.putAttr (attrKey, boTarget)
                      }
                    }
                    sb.boScope.putAttr (attrKey, attrVal)
                  }
                }
              }

            }
          }
        }
      }
    }
  }

  method superBack () {
    SuperBack(this, this._last_eid += 1)
  }

  # put the databack instance into the lexical context of its methods as `db`
  db = this

  # to be installed to every `SuperBack` as (<-^)
  method _armSuper (boScope) {
    this?boScope &> error (
      'bug: more than 1 business objects per SuperBack instance'
    )
    this.boScope = boScope

    # TODO process relationships

    # persist new business object through `db.persistSink`
    db.persistSink <- (constructor(that), this.eid, that)

    # keep a reference to it by this.eid
    db._extent[this.eid] = that
  }

  # to be installed to every `SuperBack` as (<-@) and (*<-@)
  method _setBoAttr (attrKey, attrVal) {
    attrValOld = that?$attrKey

    # disconnect old relationship as necessary
    if attrValOld != attrVal then {
      case attrValOld of {{ SuperBack: sbOldKin }} ->  {
        case sbOldKin.kins[constructor(that)] of {
          nil -> { runtime.fatal<| 'bug?' }
          { kinCntrOld } -> ai case kinCntrOld[this.eid] of {
            nil -> { runtime.fatal<| 'bug?' }
            { rc: _that } -> kinCntrOld[this.eid] = if rc > 1
              then (rc-1): that
              else nil
          }
        }
      }
    }

    # handle trivially representable values, including `nil`
    hasReConRepr(attrVal) -> {
      # update the attribute value before persist the change
      that?$attrKey = attrVal

      # persist the new attribute value
      db.persistSink <- (constructor(that), this.eid, [(attrKey, attrVal)])
    }

    # handle object references
    ObjectType == type(attrVal) -> case (boNewKin = attrVal) of {
      {{ SuperBack: sbNewKin }} -> {
        # establish new relationship
        ai case sbNewKin.kins[constructor(that)] of {
          nil -> {  # `that` is the first kin of its class to `boNewKin`
            sbNewKin.kins[constructor(that)] = ( kinCntrNew = {
              this.eid: (1: that)
            } )
          }
          { kinCntrNew } -> {  # not the first kin of its class to `boNewKin`
            case kinCntrNew[this.eid] of {
              nil -> {
                kinCntrNew[this.eid] = (1: that)
              }
              { rc: _that } -> {
                kinCntrNew[this.eid] = (rc+1: that)
              }
            }
          }
        }

        # persist the new relationship
        db.persistSink <- (constructor(that), this.eid, [
          (attrKey, constructor(boNewKin): sbNewKin.eid)]
        )
      }

      runtime.warn<| 'non-backed-object ' ++ boNewKin 
        ++ ' treated as transient attribute ' ++ attrKey 
        ++ ' for business object ' ++ this.eid
        ++ ' of class defined at ' ++ this.boScope.lexiLoc()
      continue  # no magic to impose
    }

    # leave as normal transient attribute
    runtime.debug<| 'attribute of type ' ++ type(attrVal)
      ++ ' treated as transient attribute ' ++ attrKey 
      ++ ' for business object ' ++ this.eid
      ++ ' of class defined at ' ++ this.boScope.lexiLoc()
    continue  # no magic to impose
  }

}

class SuperBack (db, eid) {

  # relationships by class
  kins = {,}

  # handles `extends db.superBack()` from a business object's class proc
  (<-^) = db._armSuper

  # use same method impl. for (<-@) and (*<-@), treating internal/external attr
  # updates the same

  # handles `this.xxx = yyy` from a business child (referred to by `that`)
  ( <-@) = db._setBoAttr
  # handles `obj.xxx = yyy` for `obj` being a business child (referred to by `that`)
  (*<-@) = db._setBoAttr

}



# import the host module
import(
  className, newBo, backToFile,
  **_
) 'db/ehi'


# this tells persistent attributes from transient ones
method hasReConRepr( attrVal ) {
 return type( attrVal ) ?<= [
    # types reconstructable from its textual representation
    nil,  # absent attribute
    BoolType, DecimalType, StringType,  # literal values
    # TODO validate deep content in a container are reconstructable from repr
    PairType, TupleType, ListType, DictType,  # containers
    ArgsPackType,  # complexer container
  ]
}

method runDbApp(dataFileName, dbApp) {

  # the producer procedure to be launched for db app
  producer launchApp( outlet ) {
    db = DataBack( outlet, dbApp )
    db.init()
  }

  # serialize the stream of sunk Edh values to the specified data file
  backToFile ( launchApp(), dataFileName )

}

class DataBackLifecycle {

  # this is the entry point of a db app, the concrete app can selectively
  # implement some of the methods invoked here.
  method init() {
    # note `that` reference won't invoke magics, just does vanilla
    # attribute resolution and do the call against the result.
    that.bootstrap()
    that.run()
    that.shutdown()
  }

  # provide default impl. of the lifecycle methods so the db app does not
  # have to impl. all of them.

  method bootstrap() pass
  
  method run() pass

  method shutdown() {
    that.persistOutlet <- nil
  }

}

class DataBack {
  extends( DataBackLifecycle() )

  method __init__ (
    persistOutlet as this.persistOutlet, 
    dbApp,
  ) {
    extends( dbApp )
  }

  # the last entity identifier allocated
  # todo change to uuid for security reasons in production, instead of the
  #      trivial natural numbers as for now
  _last_eid = 0

  # reference all live business objects by eid, with each business 
  # class having a separate dict in `_extents`
  _extents = {,}

  method superBack() {
    SuperBack( this, this._last_eid+=1 )
  }

  # settle a new business object
  # in a tx process all attributes atm
  method _settle_obj( boEnt, sbEnt ) ai {
    persistAttrs = []
    for (attrKey, attrVal) from sbEnt._boScope.attrs() do case attrVal of {
      # referencing another business object, settle the relationship
      {{ SuperBack: sbRefEnt }} ->  {
        this._settle_rel( boEnt, sbEnt, attrKey, attrVal, sbRefEnt )

        # encounter the new relationship
        (attrKey, className(attrVal), sbRefEnt.eid) => persistAttrs
      }

      # handle trivially representable values, including `nil`
      ;| hasReConRepr(attrVal) -> {
        # encounter the new attribute value
      (attrKey, attrVal) => persistAttrs
      }

      # not to persist, treating as a transient attribute
      {#
      runtime.debug<| 'attribute of type ' ++ type(attrVal)
        ++ ' treated as transient attribute ' ++ attrKey 
        ++ ' for business object ' ++ sbEnt.eid
        ++ ' of class defined at ' ++ sbEnt._boScope.lexiLoc()
      #}
    }

    # put into global extent
    ai case this._extents[constructor(boEnt)] of {
      nil -> this._extents[constructor(boEnt)] = {
        sbEnt.eid: boEnt
      }
      { boExtent } -> {
        boExtent[sb.Ent.eid] = boEnt
      }
    }

    # persist all attributes of the new business object
    this.persistOutlet <- (className(boEnt), sbEnt.eid, persistAttrs)
  }

  # settle an attribute update
  method _settle_attr( boEnt, sbEnt, attrKey, attrVal ) case attrVal of {
    # referencing another business object, settle the relationship
    {{ SuperBack: sbRefEnt }} ->  {
      this._settle_rel( boEnt, sbEnt, attrKey, attrVal, sbRefEnt )

      # persist the new relationship
      this.persistOutlet <- (className(boEnt), sbEnt.eid, [
      (attrKey, className(attrVal), sbRefEnt.eid)
      ])
    }

    # handle trivially representable values, including `nil`
    ;| hasReConRepr(attrVal) -> {
      # persist the new attribute value
      this.persistOutlet <- (className(boEnt), sbEnt.eid, [
        (attrKey, attrVal)
      ])
    }

    # not to persist, treating as a transient attribute
    {#
    runtime.debug<| 'attribute of type ' ++ type(attrVal)
      ++ ' treated as transient attribute ' ++ attrKey 
      ++ ' for business object ' ++ sbEnt.eid
      ++ ' of class defined at ' ++ sbEnt._boScope.lexiLoc()
    #}
  }

  # settle a new relationship
  method _settle_rel( boRel, sbRel, refAttr, boEnt, sbEnt ) {
    # counted reverse reference key, a pair of <rel-class>:<ref-attr>
    kinKey = constructor(boRel):refAttr

    # in a tx update the reverse reference for this very relationship
    ai case sbEnt.kins[kinKey] of {
      nil -> sbEnt.kins[kinKey] = {
        boRel: 1
      }
      { kinRCs } -> kinRCs[boRel] = case kinRCs[boRel] of {
        nil -> 1
        { rc } -> error('bug: dup reverse ref')
      }
    }
  }

  # cleanup an old relationship
  method _cleanup_rel( boRel, sbRel, refAttr, boEntOld, sbEntOld ) {
    # counted reverse reference key, a pair of <rel-class>:<ref-attr>
    kinKey = constructor(boRel):refAttr

    # update the reverse reference for this very relationship
    kinRCs = sbEnt.kins[kinKey]
    # the assignment has an implicit tx which is just enough
    kinRCs[boRel] = case kinRCs[boRel] of {
      1 -> nil  # assigning to nil just deletes the entry
      { rc } -> error('bug: reverse ref lost')
    }
  }

  method replayHistory( intakeSink ) {
    for persistRecord from intakeSink do case persistRecord of {
      nil -> { break }  # end of recorded history

      { (boClassName, eid, attrChgs) } -> {
        # db has the mounted DbApp as a super, resolving business classes
        # by name from there
        boClass = super?$boClassName
        if ClassType != type(boClass) then error (
          'Business class ' ++ boClassName ++ ' not available!'
        )

        # adapt to historical largest eid
        ai if eid > this._last_eid then
          this._last_eid = eid

        ai case this._extents[boClass] of {
          nil -> {
            this._extents[boClass] = (bocExtent = {,})
            boEnt = nil
          }
          { bocExtent } -> {
            boEnt = bocExtent[eid]
          }
        }

        case boEnt of {
          nil -> {

            # non-standard construction of the business object
            sbEnt = SuperBack( this, eid )
            boEnt = newBo( boClass, sbEnt )

            bocExtent[eid] = boEnt
          }
          {{ SuperBack: sbEnt }} -> {
            pass
          }
          error( 'bug: no SuperBack on existing bo' )
        }

        for attrChg from attrChgs do case attrChg of {

          # delete
          nil -> {

            # disconnect all relationships
            xxx

            # unref this bo from global extent
            bocExtent[eid] = nil
          }

          # change of trivial attribute
          {( attrKey, attrVal )} -> {

            # update attr without magic
            sbEnt._boScope.put(attrKey: attrVal)

          }

          # change of relationship
          {( attrKey, refClassName, refEntIdent )} -> {

            # todo disconnect old relationship

            # update relationship without magic
            sbEnt._boScope.put(attrKey: xxx)

          }

          error( 'bug: unsupported persistent attr chg pattern' )
        }
      }

      error( 'bug: unsupported persistent record pattern' )
    }
  }
}

class SuperBack {

  method __init__ (db as this.db, eid as this.eid) pass

  # reverse references from here, to referencers of `that` business object,
  # keyed by a pair of <rel-class>:<ref-attr>
  _kins = {,}

  generator kins(refClass, refAttr) {
    for (boRef, _) from this._kins[refClass:refAttr] |> {,} do
      yield boRef
  }

  # handles `extends db.superBack()` from a business object's class proc
  method (<-^) (boScope) {
    this?_boScope &> error (
      'bug: more than 1 business objects per SuperBack instance'
    )
    this._boScope = boScope

    # replaying history
    ;| nil == this?db -> { return nil }

    # settle new object
    this.db._settle_obj( that, this )
  }

  # ( <-@) handles `this.xxx = yyy` from a business child (referred to by `that`)
  # (*<-@) handles `obj.xxx = yyy` for `obj` being a business child (referred to by `that`)

  method (*<-@) (attrKey, attrVal) {
    attrValOld = that?$attrKey

    # no value change, nop
    attrValOld == attrVal -> { pass }

    # apply the attribute update
    that$attrKey = attrVal

    # replaying history
    ;| nil == this?db -> { return nil }

    # cleanup the old relationship
    case attrValOld of {{ SuperBack: sbRefEntOld }} ->
      this.db._cleanup_rel( that, this, attrKey, attrValOld, sbRefEntOld)

    # settle new attribute
    this.db._settle_attr( that, this, attrKey, attrVal )
  }

  # use same method impl. for (<-@) and (*<-@), treating internal/external attr
  # updates the same
  this.(<-@) = (*<-@)

  # TODO impl.
  method delete() {
    runtime.fatal<| 'deletion of backed business object not impl. yet'
  }

}


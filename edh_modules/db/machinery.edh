
method hasReConRepr (attrVal) {
 return type(attrVal) ?<= [
    # types reconstructable from its textual representation
    nil,  # absent attribute
    BoolType, DecimalType, StringType,  # literal values
    # TODO validate deep content in a container are reconstructable from repr
    PairType, TupleType, ListType, DictType,  # containers
    ArgsPackType,  # complexer container
  ]
}

class DataBack (persistSink) {

  _last_eid = 0  # last entity identifier
  _extent = {,}

  method restore (restoreSessions) {
    for (rsid, dataIntake, sessionDoneSig) from restoreSessions do {
      go {
        defer sessionDoneSig <- rsid  # signal session done on thread term
        for txChgs from dataIntake do {
          for txChg from txChgs do case txChg of {
            nil -> break  # end-of-session
            { (eClass, eid, attrChgs) } -> case attrChgs of {

              # delete
              nil -> this._extent[eid] = nil

              # creation
              {{ SuperBack: sb }} -> {
                sb.eid != eid -> error 'bo eid from data intake mismatch, ' ++ sb.eid
                  ++ ' vs ' ++ eid
                this._extent[eid] = attrChgs
              }

              # update
              case this._extent[eid] of -> {
                nil -> runtime.error<| 'business object lost eid=' ++ eid
                { bo } -> {
                  constructor(bo) != eClass ->  runtime.warn<| 'business object '
                    ++ eid ++ ' class mismatch ' ++ constructor(bo) ++ ' vs ' ++ eClass
                  case bo of {{ SuperBack: sb }} -> {
                    ;| bo.eid != eid -> runtime.error<| 'business object eid mismatch '
                      ++ bo.eid ++ ' vs ' ++ eid
                    for (attrName, attrVal) from attrChgs do {
                      # TODO putAttr yet to be impl.
                      sb.boScope.putAttr (attrName, attrVal)
                    }
                  }
                }

            }
          }
        }
      }
    }
  }

  method superBack () {
    SuperBack(this, this._last_eid += 1)
  }

  # put the databack instance into the lexical context of its methods as `db`
  db = this

  # to be installed to every `SuperBack` as (<-^)
  method _armSuper (boScope) {
    this?boScope &> error (
      'bug: more than 1 business objects per SuperBack instance'
    )
    this.boScope = boScope

    # TODO process relationships

    # persist new business object through `db.persistSink`
    db.persistSink <- (constructor(that), this.eid, that)

    # keep a reference to it by this.eid
    db._extent[this.eid] = that
  }

  # to be installed to every `SuperBack` as (<-@) and (*<-@)
  method _setBoAttr (attrKey, attrVal) {
    attrValOld = that?$attrKey

    # disconnect old relationship as necessary
    if attrValOld != attrVal then {
      case attrValOld of {{ SuperBack: sbOldKin }} ->  {
        case sbOldKin.kins[constructor(that)] of {
          nil -> { runtime.fatal<| 'bug?' }
          { kinCntrOld } -> ai case kinCntrOld[this.eid] of {
            nil -> { runtime.fatal<| 'bug?' }
            { rc: _that } -> kinCntrOld[this.eid] = if rc > 1
              then (rc-1): that
              else nil
          }
        }
      }
    }

    # handle trivially representable values, including `nil`
    hasReConRepr(attrVal) -> {
      # update the attribute value before persist the change
      that?$attrKey = attrVal

      # persist the new attribute value
      db.persistSink <- (constructor(that), this.eid, [(attrKey, attrVal)])
    }

    # handle object references
    ObjectType == type(attrVal) -> case (boNewKin = attrVal) of {
      {{ SuperBack: sbNewKin }} -> {
        # establish new relationship
        ai case sbNewKin.kins[constructor(that)] of {
          nil -> {  # `that` is the first kin of its class to `boNewKin`
            sbNewKin.kins[constructor(that)] = ( kinCntrNew = {
              this.eid: (1: that)
            } )
          }
          { kinCntrNew } -> {  # not the first kin of its class to `boNewKin`
            case kinCntrNew[this.eid] of {
              nil -> {
                kinCntrNew[this.eid] = (1: that)
              }
              { rc: _that } -> {
                kinCntrNew[this.eid] = (rc+1: that)
              }
            }
          }
        }

        # persist the new relationship
        db.persistSink <- (constructor(that), this.eid, [
          (attrKey, constructor(boNewKin): sbNewKin.eid)]
        )
      }

      runtime.warn<| 'non-backed-object ' ++ boNewKin 
        ++ ' treated as transient attribute ' ++ attrKey 
        ++ ' for business object ' ++ this.eid
        ++ ' of class defined at ' ++ this.boScope.lexiLoc()
      continue  # no magic to impose
    }

    # leave as normal transient attribute
    runtime.debug<| 'attribute of type ' ++ type(attrVal)
      ++ ' treated as transient attribute ' ++ attrKey 
      ++ ' for business object ' ++ this.eid
      ++ ' of class defined at ' ++ this.boScope.lexiLoc()
    continue  # no magic to impose
  }

}

class SuperBack (db, eid) {

  # relationships by class
  kins = {,}

  # handles `extends db.superBack()` from a business object's class proc
  (<-^) = db._armSuper

  # use same method impl. for (<-@) and (*<-@), treating internal/external attr
  # updates the same

  # handles `this.xxx = yyy` from a business child (referred to by `that`)
  ( <-@) = db._setBoAttr
  # handles `obj.xxx = yyy` for `obj` being a business child (referred to by `that`)
  (*<-@) = db._setBoAttr

}


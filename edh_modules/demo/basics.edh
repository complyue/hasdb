
{

  # an object in Edh can serve as a parameteric *module*, with nested classes,
  # methods and/or other procedures, those to be `import`ed into another app/lib
  # instance's scope.
  class DbLib {

    # an `__init__()` method if defined manifests the arguments to construct
    # instances of the enclosing class
    #
    # requires an effective `DataBack` instance for each instance of this lib
    method __init__ (db as this.db) pass

    class Person {

      method __init__(
        name as this.name, 
        age as this.age, 
      ) {

        # don't do the `extends` in the class procedure, that'll confuse 
        # DataBack when instances are restored by history replay, in which
        # case the Person instance is created by non-standard construction
        # with a `SuperBack` added as a super.
        extends db.superBack()
      }

      method __repr__ () {
        'Person(name=' ++ this.name ++ ', age=' ++ this.age ++ ')'
      }

    }

  }

}


{

  class DbApp {

    # the effective `DataBack` instance for this app.
    #
    # will be assigned during `bootstrap()` method, which is called from the
    # effective `DataBack` instance, after this app instance is passed to
    # `runDbApp()`
    db := '<uninitialized>'

    # this method is called before existing back data from the disk file is
    # restored by replaying history, machinery necessary for history replay
    # needs to be setup by this method.
    method bootstrap() {
      # `DataBack` instance will put `this` App as its first super,
      # `run()` is called against the db instance, so `that` here is
      # the actual `DataBack` instance.
      this.db = that

      # import some classes from a lib parameterized with current db instance.
      import * DbLib(that)

      # create global indices

      db.createIndex( expr deptByName, Depart, expr (
        name:ASC,
       ), unique=true )

      db.createIndex( expr personByName, Person, expr name:ASC )
    }

    # a business object class, should `extends db.superBack()` from its 
    # `__init__()` method, for the business object instances of this class
    # to be persisted by the effective `DataBack`.
    #
    # NOTE during history replay, when persistent objects are restored from
    #      the backing storage, an instance under goes a non-standard
    #      construction, the `__init__()` method will NOT be called as in
    #      normal construction after the class procedure is called against
    #      the new instance. so as `extends db.superBack()` carries the
    #      persistent-object-creation semantic, it should be written in 
    #      the `__init__()` method instead of in the class procedure.
    class Depart {

      method __init__(
        name as this.name,
      ) {
        this.headcount = 30

        # this actually creates this business object in persistence respect
        extends db.superBack()
      }

      # invoked on initial creation of this persistent business object, or 
      # during history replay from backing storage.
      method __db_init__ () {

        # create a kindex for persons working for this dept, sorted by salary
        super.createKinIndex(
# target attr name, will be available as super attr
          expr workers,
# business class as the relationship
          WorkFor,
# attr key on the relationship bo whose value is a reference to this bo
          expr depart,
# key attrs, descending sort by salary
          expr ( salary:DESC, ),
        )

      }

      method __repr__ () {
        'Depart(name=' ++ this.name ++ ')'
      }

    }

    class WorkFor {
      method __init__(
        person as this.person,
        depart as this.depart,
        salary as this.salary,
      ) {
        extends db.superBack()
      }
    }

    # this is the *main* method of the application, all transactional changes
    # are backed to disk file during the course of this method running.
    # once this method returns, the db is shutdown.
    method run() {

      case db.deptByName[ 'Dev' ] of {
        { dev } -> { pass }

        dev = Depart('Dev')

        compl = Person( name = 'Compl', age = 41 )
        jim = Person( name = 'Jim', age = 11 )

        WorkFor( compl, dev, 12345 )
        WorkFor( jim, dev, 54321 )
      }

      # define commands this app supports
      shutdown := Command()
      jims := Command()

      console.print(
        ' * You are in the DB app now, key in `shutdown` to commit all changes.',
        ' * Note that quiting the process (by Ctrl^D) from within the app,',
        '   without shutting down first, will leave your changes uncommitted.' )
      while true {
        case console.readCommand(ps1="(app)Đ: ", ps2="(app)Đ| ") of {
          shutdown -> { break }
          batteries.dir -> {  # custom response to the builtin `dir` command

            case db.personByName['Compl'] of { compl=>_ } -> {
              console.print( "Compl's record is: " ++ compl )
            }
            case db.personByName['Jim'] of { jim=>_ } -> {
              console.print( "Got a Jim ver# " ++ ( jim.version $=> 'legacy' ) )
            }
            console.print( 'Dev Org is ' ++ dev ++ ' with workers:')
            for (ixk, workRel) from dev.workers.range() do 
              console.print( '  ' ++ workRel.person ++ ' in order of ' ++ ixk )

          }
          jims -> {
            console.print( 'Got these versions of Jim:' )
            for jim from db.personByName['Jim'] do console.print(
              ' # ' ++ (jim.version $=> 'legacy') )
          }
          { cmdVal } -> {
            console.print( cmdVal )
            cmdVal = nil  # clear it
          }
        }
      } $=> {  # catch exceptions

        {{ ProgramHalt: ph }} -> {
          throw ph  # escalate a halt to the program loop of the
          # host interpreter, let it decide what to do.
        }

        {{ IOError:exc }} -> {
          console.fatal <| 'IO error - ' ++ exc
          throw exc  # escalate it to the program loop of the
          # host interpreter, let it decide what to do.
        }

        { cmdExc } -> {
          console.print( 'Recovered from error', exception=cmdExc )
        }

      }
      console.print( 'DB app shutting down ...' )

    }
  }

}
